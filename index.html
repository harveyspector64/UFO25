<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Xenoprobe Unit 734</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a2e; /* Dark space blue */
            font-family: 'Courier New', Courier, monospace; /* Gives a retro-tech feel */
            color: #00ffcc; /* Alien green/cyan */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
        }
        #gameContainer {
            width: 100%;
            height: 100%;
            max-width: 100vw; 
            max-height: 100vh; 
            position: relative;
            background-color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
            border: 2px solid #00ffcc;
            border-radius: 10px;
            overflow: hidden; 
        }
        canvas {
            display: block;
            background-color: #0e0e18; 
            width: 100%;
            height: 100%;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            color: #00ffcc;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 15px;
            box-sizing: border-box;
        }

        .ui-panel {
            background-color: rgba(10, 20, 40, 0.7);
            border: 1px solid #00ffcc;
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 0 8px rgba(0, 255, 204, 0.3);
            font-size: 12px; 
            line-height: 1.4;
        }

        .top-ui {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .bottom-ui {
            display: flex;
            justify-content: center; /* Center the single beam button */
            align-items: flex-end; 
            width: 100%;
            padding-bottom: 20px; 
        }

        .ui-button {
            pointer-events: all; 
            background-color: #00ffcc;
            color: #1a1a2e;
            border: none;
            border-radius: 50%; 
            width: 70px; /* Slightly larger for primary control */
            height: 70px;
            margin: 0 10px; /* Only one button now */
            font-size: 32px; 
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 0 10px #00ffcc, 0 0 15px #00ffcc inset;
            transition: background-color 0.2s, transform 0.1s;
            user-select: none; /* Prevent text selection on drag */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .ui-button:active { /* Style for when button is actively pressed */
            background-color: #00b38f;
            transform: scale(0.95);
        }
        .ui-button.active { /* Style for when beam is ON */
            background-color: #ff8c00; /* Orange to indicate active state */
            box-shadow: 0 0 15px #ff8c00, 0 0 20px #ff8c00 inset;
        }


        #directiveMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            padding: 20px;
            border: 1px solid #00ffcc;
            border-radius: 5px;
            text-align: center;
            font-size: 14px;
            z-index: 100;
            max-width: 80%;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }
        #directiveMessage.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #debugInfo { 
            position: absolute;
            bottom: 100px; /* Above button */
            left: 10px;
            font-size: 10px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 3px;
            max-height: 100px;
            overflow-y: auto;
            color: #ffcc00;
            z-index: 10;
        }

    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-overlay">
            <div class="top-ui">
                <div id="statusPanel" class="ui-panel">
                    UNIT: 734-TRN<br>
                    INTEGRITY: <span id="integrityValue">100</span>%<br>
                    ENERGY: <span id="energyValue">100</span>%
                </div>
                <div id="resourcePanel" class="ui-panel">
                    BIOMATTER: <span id="biomatterValue">0000</span><br>
                    PSYCHE-TRACE: <span id="psycheTraceValue">000</span>
                </div>
            </div>

            <div id="directiveMessage">
                //DIRECTIVE: COMMENCE SPECIMEN HARVEST. EVALUATE ORGANIC VIABILITY. AVOID SYSTEMIC DISRUPTION.//
            </div>
            
            <div id="debugInfo">Debug: Initializing...</div>

            <div class="bottom-ui">
                <button id="beamButton" class="ui-button">B</button> 
            </div>
        </div>
    </div>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');

        // UI Elements
        const integrityValueUI = document.getElementById('integrityValue');
        const energyValueUI = document.getElementById('energyValue');
        const biomatterValueUI = document.getElementById('biomatterValue');
        const psycheTraceValueUI = document.getElementById('psycheTraceValue');
        const beamButton = document.getElementById('beamButton');
        const directiveMessageUI = document.getElementById('directiveMessage');
        const debugInfoUI = document.getElementById('debugInfo');

        let gameWidth, gameHeight;

        // Sound Synthesis (Tone.js)
        let synth, beamSynthLoop, assimilateSynth, impactSynth, ambientSynth;
        let soundsReady = false;

        async function initSounds() {
            if (soundsReady) return;
            try {
                await Tone.start(); 
                synth = new Tone.Synth().toDestination(); 
                
                beamSynthLoop = new Tone.NoiseSynth({
                    noise: { type: 'pink' },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 1, release: 0.2 } // Longer sustain for loop
                }).toDestination();
                beamSynthLoop.volume.value = -25; // Quieter for continuous sound

                assimilateSynth = new Tone.Synth({
                    oscillator: { type: 'sawtooth' },
                    envelope: { attack: 0.5, decay: 1, sustain: 0.3, release: 0.5 }
                }).toDestination();
                assimilateSynth.volume.value = -10;
                
                impactSynth = new Tone.MembraneSynth().toDestination();
                impactSynth.volume.value = -5;

                // Ambient sound can be simpler or removed if too much
                // ambientSynth = new Tone.Loop(() => {
                //     if (soundsReady) synth.triggerAttackRelease("C2", "4n", Tone.now() + Math.random() * 2);
                // }, "2m").start(0);
                // ambientSynth.humanize = true;
                Tone.Transport.start();
                
                console.log("Tone.js initialized and transport started.");
                soundsReady = true;
                debugLog("Sounds initialized.");
            } catch (error) {
                console.error("Error initializing Tone.js:", error);
                debugLog("Error initializing sounds.");
            }
        }
        
        document.body.addEventListener('pointerdown', async () => { // Use pointerdown for broader compatibility
            if (!soundsReady && Tone.context.state !== 'running') {
                await initSounds();
            }
        }, { once: true });


        // --- Game State & Entities ---
        const UFO_DEFAULT_BEAM_LENGTH = 150;
        const UFO_MIN_BEAM_LENGTH = 30; // For assimilation
        const UFO_MAX_BEAM_LENGTH = 300;

        const ufo = {
            x: 0, y: 0, screenX: 0, screenY: 0,
            width: 50, height: 25, domeHeight: 15,
            speed: 3, dx: 0, dy: 0,
            targetX: 0, targetY: 0, isMoving: false,
            energy: 100, integrity: 100,
            biomatter: 0, psycheTrace: 0,
            beamActive: false,
            beamCurrentLength: UFO_DEFAULT_BEAM_LENGTH,
            beamTargetLength: UFO_DEFAULT_BEAM_LENGTH,
            beamWidth: 10,
            heldObject: null,
            beamDragStartY: 0, // For beam length control
            isDraggingBeam: false
        };

        const camera = { x: 0, y: 0, zoom: 1 };
        let gameObjects = []; 
        const TILE_SIZE = 64;
        const CHUNK_SIZE = 8; 
        const WORLD_CHUNK_RADIUS = 2; 
        let activeChunks = new Map(); 

        // --- Input Handling ---
        let touchStartX = 0, touchStartY = 0;
        let currentTouchX = 0, currentTouchY = 0;
        let isTouchingCanvas = false; // Specifically for UFO movement

        // --- Helper Functions ---
        function debugLog(message) {
            const currentText = debugInfoUI.innerHTML;
            debugInfoUI.innerHTML = `${new Date().toLocaleTimeString()}: ${message}<br>` + currentText.substring(0, 500);
        }

        function resizeCanvas() {
            gameWidth = gameContainer.clientWidth;
            gameHeight = gameContainer.clientHeight;
            canvas.width = gameWidth;
            canvas.height = gameHeight;
            ufo.screenX = gameWidth / 2;
            ufo.screenY = gameHeight / 2;
            camera.x = ufo.x - ufo.screenX;
            camera.y = ufo.y - ufo.screenY;
            debugLog(`Canvas resized: ${gameWidth}x${gameHeight}`);
        }

        function worldToScreen(worldX, worldY) {
            return { x: worldX - camera.x, y: worldY - camera.y };
        }

        function screenToWorld(screenX, screenY) {
            return { x: screenX + camera.x, y: screenY + camera.y };
        }
        
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // --- Procedural Generation (largely unchanged) ---
        function getChunkKey(chunkX, chunkY) { return `${chunkX},${chunkY}`; }
        function generateChunk(chunkX, chunkY) {
            const chunk = { x: chunkX, y: chunkY, tiles: [], objects: [], baseColor: `rgb(${getRandomInt(30,60)}, ${getRandomInt(100,150)}, ${getRandomInt(30,60)})`};
            const numObjectsInChunk = getRandomInt(1, 5);
            for (let i = 0; i < numObjectsInChunk; i++) {
                const objX = chunkX * CHUNK_SIZE * TILE_SIZE + Math.random() * CHUNK_SIZE * TILE_SIZE;
                const objY = chunkY * CHUNK_SIZE * TILE_SIZE + Math.random() * CHUNK_SIZE * TILE_SIZE;
                const objTypeRoll = Math.random();
                if (objTypeRoll < 0.5) gameObjects.push(createCow(objX, objY));
                else if (objTypeRoll < 0.7) gameObjects.push(createTree(objX, objY));
                else if (objTypeRoll < 0.8 && Math.random() < 0.1) gameObjects.push(createFarmhouse(objX, objY));
            }
            return chunk;
        }
        function updateActiveChunks() {
            const ufoChunkX = Math.floor(ufo.x / (CHUNK_SIZE * TILE_SIZE));
            const ufoChunkY = Math.floor(ufo.y / (CHUNK_SIZE * TILE_SIZE));
            let newActiveChunks = new Map();
            for (let dx = -WORLD_CHUNK_RADIUS; dx <= WORLD_CHUNK_RADIUS; dx++) {
                for (let dy = -WORLD_CHUNK_RADIUS; dy <= WORLD_CHUNK_RADIUS; dy++) {
                    const cx = ufoChunkX + dx; const cy = ufoChunkY + dy;
                    const key = getChunkKey(cx, cy);
                    if (activeChunks.has(key)) newActiveChunks.set(key, activeChunks.get(key));
                    else newActiveChunks.set(key, generateChunk(cx, cy));
                }
            }
            activeChunks = newActiveChunks;
            gameObjects = gameObjects.filter(obj => {
                const distSq = (obj.x - ufo.x)**2 + (obj.y - ufo.y)**2;
                const maxDist = (WORLD_CHUNK_RADIUS + 1) * CHUNK_SIZE * TILE_SIZE;
                return distSq < maxDist**2;
            });
        }

        // --- Game Object Creation (largely unchanged, added held object physics props) ---
        function createCow(x, y) {
            return { type: 'cow', x, y, width: 30, height: 20, color: `rgb(200, 200, 180)`, 
                     speed: 0.5, vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5,
                     state: 'wandering', fleeTimer: 0, mass: 100, canBeAssimilated: true, biomatterYield: 10,
                     heldAngle: 0, heldAngleVel: 0 }; // For swinging
        }
        function createTree(x,y){
            return { type: 'tree', x, y, trunkWidth: 10, trunkHeight: 20, canopyRadius: 25,
                     trunkColor: `rgb(139,69,19)`, canopyColor: `rgb(34,139,34)`, mass: 150, canBeAssimilated: false,
                     heldAngle: 0, heldAngleVel: 0 };
        }
        function createFarmhouse(x,y){
             return { type: 'farmhouse', x, y, width: 80, height: 60, color: `rgb(200,180,160)`, roofColor: `rgb(150,50,50)`,
                      mass: 1000, canBeAssimilated: false, heldAngle: 0, heldAngleVel: 0 };
        }

        // --- UFO Controls & Beam ---
        function handleCanvasPointerDown(e) {
            e.preventDefault();
            // Check if the event target is the canvas itself, not a button
            if (e.target !== canvas) return;

            isTouchingCanvas = true;
            ufo.isMoving = true;
            
            currentTouchX = e.clientX;
            currentTouchY = e.clientY;
            // Convert touch to world coords for initial target to avoid jump
            const worldPos = screenToWorld(currentTouchX, currentTouchY);
            ufo.targetX = worldPos.x; 
            ufo.targetY = worldPos.y;

            if (!directiveMessageUI.classList.contains('hidden')) {
                directiveMessageUI.classList.add('hidden');
            }
            if (!soundsReady && Tone.context.state !== 'running') { initSounds(); }
            debugLog(`Canvas Touch Start: UFO Target ${ufo.targetX.toFixed(0)}, ${ufo.targetY.toFixed(0)}`);
        }

        function handleCanvasPointerMove(e) {
            e.preventDefault();
            if (!isTouchingCanvas) return;
            
            const deltaX = e.clientX - currentTouchX;
            const deltaY = e.clientY - currentTouchY;

            // Update UFO target world position directly by the drag delta
            // The UFO movement logic in update() will handle moving towards this.
            ufo.targetX += deltaX; 
            ufo.targetY += deltaY;
            
            currentTouchX = e.clientX;
            currentTouchY = e.clientY;
        }

        function handleCanvasPointerUp(e) {
            e.preventDefault();
            if (isTouchingCanvas) {
                isTouchingCanvas = false;
                // ufo.isMoving = false; // Let it glide
                debugLog("Canvas Touch End");
            }
        }
        
        // Beam Button Logic
        let beamButtonTouchId = null;
        let beamButtonInitialDragY = 0;
        let beamButtonWasDragged = false;

        beamButton.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            e.target.setPointerCapture(e.pointerId); // Capture pointer for this button
            beamButtonTouchId = e.pointerId;
            beamButtonWasDragged = false;

            if (ufo.beamActive) {
                ufo.isDraggingBeam = true;
                beamButtonInitialDragY = e.clientY;
                ufo.beamDragStartY = ufo.beamTargetLength; // Store current target length to drag from
                debugLog("Beam drag START");
            } else {
                 // This path is for activating the beam on a tap (handled in pointerup if not dragged)
            }
        });

        beamButton.addEventListener('pointermove', (e) => {
            if (!ufo.beamActive || !ufo.isDraggingBeam || e.pointerId !== beamButtonTouchId) return;
            e.preventDefault();
            beamButtonWasDragged = true;

            const deltaY = e.clientY - beamButtonInitialDragY;
            // Sensitivity: adjust how much drag affects length
            const dragSensitivity = 1.5; 
            ufo.beamTargetLength = ufo.beamDragStartY + deltaY * dragSensitivity;
            ufo.beamTargetLength = Math.max(UFO_MIN_BEAM_LENGTH, Math.min(UFO_MAX_BEAM_LENGTH, ufo.beamTargetLength));
            // debugLog(`Beam dragging: TargetLength ${ufo.beamTargetLength.toFixed(0)}`);
        });

        beamButton.addEventListener('pointerup', (e) => {
            e.preventDefault();
            if (e.pointerId !== beamButtonTouchId) return;
            e.target.releasePointerCapture(e.pointerId);
            beamButtonTouchId = null;

            if (ufo.isDraggingBeam) {
                ufo.isDraggingBeam = false;
                debugLog("Beam drag END");
                // Beam remains active, length set by drag
            } else { // Was a tap, not a drag
                ufo.beamActive = !ufo.beamActive; // Toggle beam
                if (ufo.beamActive) {
                    ufo.beamTargetLength = UFO_DEFAULT_BEAM_LENGTH; // Reset to default on activation
                    ufo.beamCurrentLength = UFO_DEFAULT_BEAM_LENGTH;
                    if (soundsReady && beamSynthLoop && beamSynthLoop.state !== "started") {
                        beamSynthLoop.triggerAttack();
                    }
                    beamButton.classList.add('active');
                    debugLog("Beam ON (tap)");
                } else {
                    if (soundsReady && beamSynthLoop && beamSynthLoop.state === "started") {
                        beamSynthLoop.triggerRelease();
                    }
                    beamButton.classList.remove('active');
                    if (ufo.heldObject) { // Throw object
                        ufo.heldObject.vx = ufo.dx * 1.5 + (ufo.heldObject.heldAngleVel || 0) * 5; // Add swing velocity
                        ufo.heldObject.vy = ufo.dy * 1.5 - 5; // Upward push from release
                        ufo.heldObject.isFalling = true;
                        debugLog(`Threw ${ufo.heldObject.type}`);
                        ufo.heldObject = null;
                    }
                    debugLog("Beam OFF (tap)");
                }
            }
            beamButtonWasDragged = false; // Reset for next interaction
        });


        // --- Game Logic Update ---
        function update(deltaTime) {
            // UFO Movement towards target (from canvas drag)
            if (ufo.isMoving || ufo.targetX !== ufo.x || ufo.targetY !== ufo.y) {
                const angle = Math.atan2(ufo.targetY - ufo.y, ufo.targetX - ufo.x);
                const targetDx = Math.cos(angle) * ufo.speed;
                const targetDy = Math.sin(angle) * ufo.speed;
                ufo.dx += (targetDx - ufo.dx) * 0.1;
                ufo.dy += (targetDy - ufo.dy) * 0.1;
                const distToTargetSq = (ufo.targetX - ufo.x)**2 + (ufo.targetY - ufo.y)**2;
                if (distToTargetSq < (ufo.speed * 2)**2) {
                     if(!isTouchingCanvas) { 
                        ufo.dx *= 0.9; ufo.dy *= 0.9;
                        if (Math.abs(ufo.dx) < 0.1 && Math.abs(ufo.dy) < 0.1) {
                            ufo.dx = 0; ufo.dy = 0; ufo.isMoving = false;
                        }
                     }
                }
            } else { 
                ufo.dx *= 0.95; ufo.dy *= 0.95;
                if (Math.abs(ufo.dx) < 0.1) ufo.dx = 0;
                if (Math.abs(ufo.dy) < 0.1) ufo.dy = 0;
            }
            ufo.x += ufo.dx; ufo.y += ufo.dy;

            camera.x = ufo.x - ufo.screenX; camera.y = ufo.y - ufo.screenY;
            updateActiveChunks();

            // Beam Length interpolation
            if (Math.abs(ufo.beamCurrentLength - ufo.beamTargetLength) > 0.5) {
                ufo.beamCurrentLength += (ufo.beamTargetLength - ufo.beamCurrentLength) * 0.2; // Smooth transition
            } else {
                ufo.beamCurrentLength = ufo.beamTargetLength;
            }

            // Beam Logic
            if (ufo.beamActive && ufo.energy > 0) {
                ufo.energy -= 0.05; // Slightly lower continuous cost
                if (ufo.energy < 0) ufo.energy = 0;

                if (!ufo.heldObject) {
                    let closestObject = null; let minDistanceSq = Infinity;
                    const beamWorldX = ufo.x; 
                    const beamTipWorldY = ufo.y + ufo.height / 2 + ufo.beamCurrentLength;

                    gameObjects.forEach(obj => {
                        if (obj.isFalling || obj === ufo.heldObject) return;
                        // Check if object is within beam's cone
                        const lateralDist = Math.abs(obj.x - beamWorldX);
                        const verticalDist = Math.abs(obj.y - beamTipWorldY);
                        const beamEffectiveRadius = ufo.beamWidth + obj.width/2; // More generous capture
                        
                        if (lateralDist < beamEffectiveRadius && verticalDist < obj.height + 20) { // Check vertical proximity to tip
                            const distSq = (obj.x - beamWorldX)**2 + (obj.y - beamTipWorldY)**2;
                            if (distSq < minDistanceSq && obj.mass < 500) {
                                closestObject = obj;
                                minDistanceSq = distSq;
                            }
                        }
                    });

                    if (closestObject) {
                        ufo.heldObject = closestObject;
                        ufo.heldObject.heldAngle = 0; // Reset swing angle
                        ufo.heldObject.heldAngleVel = 0;
                        if (soundsReady) synth.triggerAttackRelease("G4", "0.1s");
                        debugLog(`Picked up ${ufo.heldObject.type}`);
                    }
                }
            } else { // Beam is not active or no energy
                if (ufo.beamActive && ufo.energy <= 0) { 
                    ufo.beamActive = false; // Turn off beam
                    beamButton.classList.remove('active');
                    if (soundsReady && beamSynthLoop && beamSynthLoop.state === "started") beamSynthLoop.triggerRelease();
                    if (soundsReady) synth.triggerAttackRelease("C3", "0.5s"); 
                    if (ufo.heldObject) { // Drop object if energy runs out
                        ufo.heldObject.isFalling = true;
                        ufo.heldObject = null;
                    }
                }
            }
            
            // Held Object Logic & Swinging & Assimilation
            if (ufo.heldObject) {
                ufo.energy -= 0.02 * (ufo.heldObject.mass / 100); // Energy cost to hold

                // Swinging physics (simple pendulum)
                const beamAnchorX = ufo.x;
                const beamAnchorY = ufo.y + ufo.height / 2;
                const restX = beamAnchorX; // Target X directly under UFO
                const restY = beamAnchorY + ufo.beamCurrentLength; // Target Y at beam end

                // Calculate current object position based on angle for rendering
                const actualHeldX = beamAnchorX + Math.sin(ufo.heldObject.heldAngle) * ufo.beamCurrentLength;
                const actualHeldY = beamAnchorY + Math.cos(ufo.heldObject.heldAngle) * ufo.beamCurrentLength;
                
                // Force pulling towards rest position (center of beam)
                // More complex: treat beam as a spring-damper system for angle
                const angleToRest = Math.atan2(ufo.x - actualHeldX, (ufo.y + ufo.height/2 + ufo.beamCurrentLength) - actualHeldY);
                const targetAngle = 0; // Target is straight down
                
                let restoringForce = (targetAngle - ufo.heldObject.heldAngle) * 0.005; // Spring constant for angle
                restoringForce -= ufo.heldObject.heldAngleVel * 0.05; // Damping for angle

                // Influence from UFO movement
                const ufoInfluence = ufo.dx / (ufo.beamCurrentLength * 0.1 + 1); // UFO dx affects angular velocity
                ufo.heldObject.heldAngleVel += restoringForce - ufoInfluence * 0.01;
                
                ufo.heldObject.heldAngle += ufo.heldObject.heldAngleVel;
                ufo.heldObject.heldAngleVel *= 0.95; // General damping

                // Clamp angle to avoid excessive swinging
                ufo.heldObject.heldAngle = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, ufo.heldObject.heldAngle));


                ufo.heldObject.x = beamAnchorX + Math.sin(ufo.heldObject.heldAngle) * ufo.beamCurrentLength;
                ufo.heldObject.y = beamAnchorY + Math.cos(ufo.heldObject.heldAngle) * ufo.beamCurrentLength;
                
                ufo.heldObject.isFalling = false;

                // Assimilation Check
                if (ufo.heldObject.canBeAssimilated && ufo.beamCurrentLength <= UFO_MIN_BEAM_LENGTH + 5 && ufo.energy > 10) {
                    if (soundsReady) assimilateSynth.triggerAttackRelease("C4", "1s");
                    debugLog(`Assimilating ${ufo.heldObject.type}`);
                    ufo.energy -= 10; 
                    if(ufo.heldObject.biomatterYield) ufo.biomatter += ufo.heldObject.biomatterYield;
                    if(ufo.heldObject.psycheTraceYield) ufo.psycheTrace += ufo.heldObject.psycheTraceYield;
                    const index = gameObjects.indexOf(ufo.heldObject);
                    if (index > -1) gameObjects.splice(index, 1);
                    ufo.heldObject = null;
                    // Optional: Turn off beam or retract fully? For now, just releases object.
                    // ufo.beamActive = false; beamButton.classList.remove('active');
                    // if (soundsReady && beamSynthLoop.state === "started") beamSynthLoop.triggerRelease();
                }
            }

            // Update Game Objects (NPCs, etc.)
            gameObjects.forEach(obj => {
                if (obj === ufo.heldObject) return; // Skip if held

                if (obj.type === 'cow') {
                    const ufoDistSq = (obj.x - ufo.x)**2 + (obj.y - ufo.y)**2;
                    if (ufoDistSq < (150)**2 || obj.fleeTimer > 0) { 
                        obj.state = 'fleeing';
                        if (obj.fleeTimer <=0) obj.fleeTimer = 180; 
                        const angleToUFO = Math.atan2(ufo.y - obj.y, ufo.x - obj.x);
                        obj.vx = -Math.cos(angleToUFO) * obj.speed * 2; 
                        obj.vy = -Math.sin(angleToUFO) * obj.speed * 2;
                    } else {
                        obj.state = 'wandering';
                        if (Math.random() < 0.01) { 
                            obj.vx = (Math.random() - 0.5) * obj.speed;
                            obj.vy = (Math.random() - 0.5) * obj.speed;
                        }
                    }
                    obj.x += obj.vx; obj.y += obj.vy;
                    if (obj.fleeTimer > 0) obj.fleeTimer--;
                } else if (obj.isFalling) {
                    obj.vy += 0.5; obj.y += obj.vy; obj.x += obj.vx;
                    const groundLevel = screenToWorld(0, gameHeight - TILE_SIZE/2).y; // More accurate ground
                    if (obj.y > groundLevel - (obj.height || obj.canopyRadius || 10)/2) {
                        obj.y = groundLevel - (obj.height || obj.canopyRadius || 10)/2;
                        obj.isFalling = false; obj.vx = 0; obj.vy = 0;
                        if (soundsReady) impactSynth.triggerAttackRelease("C2", "0.3s", Tone.now(), Math.min(0.8, obj.mass/200) );
                        debugLog(`${obj.type} hit ground.`);
                    }
                }
            });

            if (ufo.energy < 100) {
                ufo.energy += 0.05;
                if (ufo.energy > 100) ufo.energy = 100;
            }

            integrityValueUI.textContent = Math.floor(ufo.integrity);
            energyValueUI.textContent = Math.floor(ufo.energy);
            biomatterValueUI.textContent = ufo.biomatter.toString().padStart(4, '0');
            psycheTraceValueUI.textContent = ufo.psycheTrace.toString().padStart(3, '0');
        }

        // --- Rendering (Beam and UFO rendering adjusted) ---
        function draw() {
            ctx.clearRect(0, 0, gameWidth, gameHeight);

            activeChunks.forEach(chunk => { /* ... unchanged chunk drawing ... */ 
                const screenPos = worldToScreen(chunk.x * CHUNK_SIZE * TILE_SIZE, chunk.y * CHUNK_SIZE * TILE_SIZE);
                const chunkSizePixels = CHUNK_SIZE * TILE_SIZE;
                if (screenPos.x + chunkSizePixels < 0 || screenPos.x > gameWidth ||
                    screenPos.y + chunkSizePixels < 0 || screenPos.y > gameHeight) {
                    return; 
                }
                ctx.fillStyle = chunk.baseColor || '#2a3f2a'; 
                ctx.fillRect(screenPos.x, screenPos.y, chunkSizePixels, chunkSizePixels);
            });

            gameObjects.sort((a,b) => (a.y + (a.height || 0)/2) - (b.y + (b.height || 0)/2)); // Simple Y-sort for depth

            gameObjects.forEach(obj => { /* ... unchanged object drawing ... */ 
                const sPos = worldToScreen(obj.x, obj.y);
                if (sPos.x + (obj.width || obj.canopyRadius || 0) < 0 || sPos.x - (obj.width || obj.canopyRadius || 0) > gameWidth ||
                    sPos.y + (obj.height || obj.canopyRadius || 0) < 0 || sPos.y - (obj.height || obj.canopyRadius || 0) > gameHeight) {
                    return; 
                }
                ctx.save();
                ctx.translate(sPos.x, sPos.y);
                if (obj.type === 'cow') {
                    ctx.fillStyle = obj.color;
                    ctx.beginPath(); ctx.ellipse(0, 0, obj.width / 2, obj.height / 2, 0, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(obj.width / 2 * (obj.vx > 0 ? 0.6 : -0.6), -obj.height/4, obj.width / 4, obj.height / 4, 0, 0, Math.PI * 2); ctx.fill();
                } else if (obj.type === 'tree') {
                    ctx.fillStyle = obj.trunkColor; ctx.fillRect(-obj.trunkWidth / 2, 0, obj.trunkWidth, obj.trunkHeight);
                    ctx.fillStyle = obj.canopyColor; ctx.beginPath(); ctx.arc(0, -obj.canopyRadius / 2, obj.canopyRadius, 0, Math.PI * 2); ctx.fill();
                } else if (obj.type === 'farmhouse') {
                    ctx.fillStyle = obj.color; ctx.fillRect(-obj.width/2, -obj.height/2, obj.width, obj.height);
                    ctx.fillStyle = obj.roofColor; ctx.beginPath(); ctx.moveTo(-obj.width/2 - 5, -obj.height/2);
                    ctx.lineTo(obj.width/2 + 5, -obj.height/2); ctx.lineTo(0, -obj.height/2 - obj.height*0.4); ctx.closePath(); ctx.fill();
                }
                ctx.restore();
            });
            
            // Draw Tractor Beam (BEFORE UFO if object is "behind" it due to swing)
            const ufoScreenPos = worldToScreen(ufo.x, ufo.y);
            if (ufo.beamActive && ufo.energy > 0) {
                const beamAnchorScreenX = ufoScreenPos.x;
                const beamAnchorScreenY = ufoScreenPos.y + ufo.height / 2;
                
                let beamTipScreenX, beamTipScreenY;
                if (ufo.heldObject) {
                    const heldObjScreenPos = worldToScreen(ufo.heldObject.x, ufo.heldObject.y);
                    beamTipScreenX = heldObjScreenPos.x;
                     // Adjust tip to be at the center of the object, slightly above its base
                    beamTipScreenY = heldObjScreenPos.y - (ufo.heldObject.height || ufo.heldObject.canopyRadius || 10) * 0.25;
                } else {
                    beamTipScreenX = beamAnchorScreenX; // Straight down if nothing held
                    beamTipScreenY = beamAnchorScreenY + ufo.beamCurrentLength;
                }

                ctx.beginPath();
                // Wider at UFO, tapers towards tip or object
                ctx.moveTo(beamAnchorScreenX - ufo.beamWidth, beamAnchorScreenY);
                ctx.lineTo(beamTipScreenX - ufo.beamWidth * 0.3, beamTipScreenY); // Tapered end
                ctx.lineTo(beamTipScreenX + ufo.beamWidth * 0.3, beamTipScreenY);
                ctx.lineTo(beamAnchorScreenX + ufo.beamWidth, beamAnchorScreenY);
                ctx.closePath();

                const gradient = ctx.createLinearGradient(beamAnchorScreenX, beamAnchorScreenY, beamTipScreenX, beamTipScreenY);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.2)');
                gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.6)');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0.2)');
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            // Draw UFO
            ctx.save();
            ctx.translate(ufoScreenPos.x, ufoScreenPos.y);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(0, ufo.height / 2 + 5, ufo.width / 2, ufo.width / 4, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#7f8c8d'; 
            ctx.beginPath(); ctx.ellipse(0, 0, ufo.width / 2, ufo.height / 2, 0, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#95a5a6'; ctx.lineWidth = 2; ctx.stroke();
            ctx.fillStyle = '#3498db'; 
            ctx.beginPath(); ctx.ellipse(0, -ufo.height / 4, ufo.width / 3, ufo.domeHeight / 2, 0, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#5dade2'; ctx.stroke();
            ctx.restore();
        }

        // --- Game Loop ---
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000; 
            lastTime = timestamp;
            update(deltaTime);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Initialization ---
        window.addEventListener('resize', resizeCanvas);
        
        canvas.addEventListener('pointerdown', handleCanvasPointerDown, { passive: false });
        canvas.addEventListener('pointermove', handleCanvasPointerMove, { passive: false });
        canvas.addEventListener('pointerup', handleCanvasPointerUp, { passive: false });
        canvas.addEventListener('pointercancel', handleCanvasPointerUp, { passive: false });

        resizeCanvas(); 
        ufo.x = 0; ufo.y = 0;
        ufo.targetX = ufo.x; ufo.targetY = ufo.y;
        camera.x = ufo.x - ufo.screenX; camera.y = ufo.y - ufo.screenY;
        updateActiveChunks(); 
        if(gameObjects.length < 5) {
            for(let i=0; i<5; i++) gameObjects.push(createCow(Math.random()*500-250, Math.random()*500-250));
        }
        setTimeout(() => {
            if (!directiveMessageUI.classList.contains('hidden')) {
                directiveMessageUI.classList.add('hidden');
            }
        }, 7000); // Slightly longer initial message display

        debugLog("Game v0.2 initialized. Beam overhaul.");
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
