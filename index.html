<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Xenoprobe Unit 734</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a2e; /* Dark space blue */
            font-family: 'Courier New', Courier, monospace; /* Gives a retro-tech feel */
            color: #00ffcc; /* Alien green/cyan */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
        }
        #gameContainer {
            width: 100%;
            height: 100%;
            max-width: 100vw; /* Ensure it fits viewport width */
            max-height: 100vh; /* Ensure it fits viewport height */
            position: relative;
            background-color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
            border: 2px solid #00ffcc;
            border-radius: 10px;
            overflow: hidden; /* Important for canvas positioning */
        }
        canvas {
            display: block;
            background-color: #0e0e18; /* Darker ground color */
            width: 100%;
            height: 100%;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to canvas unless on a button */
            color: #00ffcc;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 15px;
            box-sizing: border-box;
        }

        .ui-panel {
            background-color: rgba(10, 20, 40, 0.7);
            border: 1px solid #00ffcc;
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 0 8px rgba(0, 255, 204, 0.3);
            font-size: 12px; /* Adjusted for better mobile readability */
            line-height: 1.4;
        }

        .top-ui {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .bottom-ui {
            display: flex;
            justify-content: center;
            align-items: flex-end; /* Align buttons to bottom */
            width: 100%;
            padding-bottom: 20px; /* Extra padding for home bar on iOS */
        }

        .ui-button {
            pointer-events: all; /* Enable clicks on buttons */
            background-color: #00ffcc;
            color: #1a1a2e;
            border: none;
            border-radius: 50%; /* Circular buttons */
            width: 60px;
            height: 60px;
            margin: 0 15px;
            font-size: 28px; /* Icon size */
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 0 10px #00ffcc, 0 0 15px #00ffcc inset;
            transition: background-color 0.2s, transform 0.1s;
        }
        .ui-button:active {
            background-color: #00b38f;
            transform: scale(0.95);
        }
        .ui-button.hidden {
            display: none;
        }

        #directiveMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            padding: 20px;
            border: 1px solid #00ffcc;
            border-radius: 5px;
            text-align: center;
            font-size: 14px;
            z-index: 100;
            max-width: 80%;
        }

        /* For slider-like control (conceptual, if needed later) */
        .slider-control {
            width: 100px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            position: relative;
        }
        .slider-thumb {
            width: 30px;
            height: 30px;
            background: #00ffcc;
            border-radius: 50%;
            position: absolute;
            top: -5px;
        }
        #debugInfo { /* For debugging on device */
            position: absolute;
            bottom: 80px; /* Above buttons */
            left: 10px;
            font-size: 10px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 3px;
            max-height: 100px;
            overflow-y: auto;
            color: #ffcc00;
        }

    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-overlay">
            <div class="top-ui">
                <div id="statusPanel" class="ui-panel">
                    UNIT: 734-TRN<br>
                    INTEGRITY: <span id="integrityValue">100</span>%<br>
                    ENERGY: <span id="energyValue">100</span>%
                </div>
                <div id="resourcePanel" class="ui-panel">
                    BIOMATTER: <span id="biomatterValue">0000</span><br>
                    PSYCHE-TRACE: <span id="psycheTraceValue">000</span>
                </div>
            </div>

            <div id="directiveMessage">
                //DIRECTIVE: COMMENCE SPECIMEN HARVEST. EVALUATE ORGANIC VIABILITY. AVOID SYSTEMIC DISRUPTION.//
            </div>
            
            <div id="debugInfo">Debug: Initializing...</div>


            <div class="bottom-ui">
                <button id="beamButton" class="ui-button">B</button> <button id="assimilateButton" class="ui-button hidden">A</button> </div>
        </div>
    </div>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');

        // UI Elements
        const integrityValueUI = document.getElementById('integrityValue');
        const energyValueUI = document.getElementById('energyValue');
        const biomatterValueUI = document.getElementById('biomatterValue');
        const psycheTraceValueUI = document.getElementById('psycheTraceValue');
        const beamButton = document.getElementById('beamButton');
        const assimilateButton = document.getElementById('assimilateButton');
        const directiveMessageUI = document.getElementById('directiveMessage');
        const debugInfoUI = document.getElementById('debugInfo');

        let gameWidth, gameHeight;

        // Sound Synthesis (Tone.js)
        let synth, beamSynth, assimilateSynth, impactSynth, ambientSynth;
        let soundsReady = false;

        async function initSounds() {
            await Tone.start(); // Required for user gesture
            synth = new Tone.Synth().toDestination(); // General purpose
            
            beamSynth = new Tone.NoiseSynth({
                noise: { type: 'pink' },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.8, release: 0.2 }
            }).toDestination();
            beamSynth.volume.value = -20;

            assimilateSynth = new Tone.Synth({
                oscillator: { type: 'sawtooth' },
                envelope: { attack: 0.5, decay: 1, sustain: 0.3, release: 0.5 }
            }).toDestination();
            assimilateSynth.volume.value = -10;
            
            impactSynth = new Tone.MembraneSynth().toDestination();
            impactSynth.volume.value = -5;

            ambientSynth = new Tone.Loop(() => {
                if (soundsReady) { // Check to prevent errors if not fully loaded
                    synth.triggerAttackRelease("C2", "4n", Tone.now() + Math.random() * 2);
                }
            }, "2m").start(0);
            ambientSynth.humanize = true;
            Tone.Transport.start();
            
            console.log("Tone.js initialized and transport started.");
            soundsReady = true;
            debugLog("Sounds initialized.");
        }
        
        // Call initSounds after a user interaction (e.g. a start button, or first touch)
        // For now, we'll try to initialize it on load, but it might require a tap.
        // A common pattern is to have a "Click to Start" screen.
        document.body.addEventListener('click', async () => {
            if (!soundsReady && Tone.context.state !== 'running') {
                await initSounds();
            }
        }, { once: true });


        // --- Game State & Entities ---
        const ufo = {
            x: 0, // World coordinates
            y: 0, // World coordinates
            screenX: 0, // Screen coordinates (center)
            screenY: 0, // Screen coordinates (center)
            width: 50,
            height: 25,
            domeHeight: 15,
            speed: 3, // Max speed
            dx: 0, // Current velocity x
            dy: 0, // Current velocity y
            targetX: 0, // For touch movement
            targetY: 0, // For touch movement
            isMoving: false,
            energy: 100,
            integrity: 100,
            biomatter: 0,
            psycheTrace: 0,
            beamActive: false,
            beamLength: 150,
            beamWidth: 10,
            heldObject: null
        };

        const camera = {
            x: 0,
            y: 0,
            zoom: 1 // Not implemented yet, but good to have
        };

        let gameObjects = []; // Cows, humans, tractors, trees etc.
        const TILE_SIZE = 64;
        const CHUNK_SIZE = 8; // 8x8 tiles per chunk
        const WORLD_CHUNK_RADIUS = 2; // Load chunks in a 5x5 grid around player's chunk (2 = (2*2+1) = 5)
        let activeChunks = new Map(); // Key: "x,y", Value: chunk data

        // --- Input Handling ---
        let touchStartX = 0;
        let touchStartY = 0;
        let currentTouchX = 0;
        let currentTouchY = 0;
        let isTouching = false;

        // --- Helper Functions ---
        function debugLog(message) {
            // console.log(message);
            // Prepend to debugInfoUI to see latest messages first
            const currentText = debugInfoUI.innerHTML;
            debugInfoUI.innerHTML = `${new Date().toLocaleTimeString()}: ${message}<br>` + currentText.substring(0, 500);
        }

        function resizeCanvas() {
            gameWidth = gameContainer.clientWidth;
            gameHeight = gameContainer.clientHeight;
            canvas.width = gameWidth;
            canvas.height = gameHeight;
            ufo.screenX = gameWidth / 2;
            ufo.screenY = gameHeight / 2;
            // Center camera on UFO's starting world position
            camera.x = ufo.x - ufo.screenX;
            camera.y = ufo.y - ufo.screenY;
            debugLog(`Canvas resized: ${gameWidth}x${gameHeight}`);
        }

        function worldToScreen(worldX, worldY) {
            return {
                x: worldX - camera.x,
                y: worldY - camera.y
            };
        }

        function screenToWorld(screenX, screenY) {
            return {
                x: screenX + camera.x,
                y: screenY + camera.y
            };
        }
        
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // --- Procedural Generation ---
        function getChunkKey(chunkX, chunkY) {
            return `${chunkX},${chunkY}`;
        }

        function generateChunk(chunkX, chunkY) {
            const chunk = {
                x: chunkX,
                y: chunkY,
                tiles: [], // For detailed terrain features if needed
                objects: [] // NPCs, structures in this chunk
            };

            // Basic terrain type for the chunk (e.g., field, road area)
            // For now, mostly fields with some random elements
            const terrainType = Math.random();
            let baseColor;
            if (terrainType < 0.7) baseColor = `rgb(${getRandomInt(30,60)}, ${getRandomInt(100,150)}, ${getRandomInt(30,60)})`; // Field green
            else if (terrainType < 0.85) baseColor = `rgb(${getRandomInt(100,130)}, ${getRandomInt(80,100)}, ${getRandomInt(50,70)})`; // Dirt path
            else baseColor = `rgb(${getRandomInt(50,80)}, ${getRandomInt(120,170)}, ${getRandomInt(50,80)})`; // Slightly different field

            chunk.baseColor = baseColor;

            // Add some objects to the chunk
            const numObjectsInChunk = getRandomInt(1, 5);
            for (let i = 0; i < numObjectsInChunk; i++) {
                const objX = chunkX * CHUNK_SIZE * TILE_SIZE + Math.random() * CHUNK_SIZE * TILE_SIZE;
                const objY = chunkY * CHUNK_SIZE * TILE_SIZE + Math.random() * CHUNK_SIZE * TILE_SIZE;
                
                const objTypeRoll = Math.random();
                if (objTypeRoll < 0.5) { // Cow
                    gameObjects.push(createCow(objX, objY));
                } else if (objTypeRoll < 0.7) { // Tree
                     gameObjects.push(createTree(objX, objY));
                } else if (objTypeRoll < 0.8 && Math.random() < 0.1) { // Farmhouse (rare)
                    gameObjects.push(createFarmhouse(objX, objY));
                }
                // More object types: tractors, humans, fences etc.
            }
            return chunk;
        }

        function updateActiveChunks() {
            const ufoChunkX = Math.floor(ufo.x / (CHUNK_SIZE * TILE_SIZE));
            const ufoChunkY = Math.floor(ufo.y / (CHUNK_SIZE * TILE_SIZE));

            let newActiveChunks = new Map();
            for (let dx = -WORLD_CHUNK_RADIUS; dx <= WORLD_CHUNK_RADIUS; dx++) {
                for (let dy = -WORLD_CHUNK_RADIUS; dy <= WORLD_CHUNK_RADIUS; dy++) {
                    const cx = ufoChunkX + dx;
                    const cy = ufoChunkY + dy;
                    const key = getChunkKey(cx, cy);
                    if (activeChunks.has(key)) {
                        newActiveChunks.set(key, activeChunks.get(key));
                    } else {
                        newActiveChunks.set(key, generateChunk(cx, cy));
                    }
                }
            }
            activeChunks = newActiveChunks;

            // Prune distant gameObjects (simple for now, could be tied to chunks)
            gameObjects = gameObjects.filter(obj => {
                const distSq = (obj.x - ufo.x)**2 + (obj.y - ufo.y)**2;
                const maxDist = (WORLD_CHUNK_RADIUS + 1) * CHUNK_SIZE * TILE_SIZE;
                return distSq < maxDist**2;
            });
        }


        // --- Game Object Creation ---
        function createCow(x, y) {
            return {
                type: 'cow',
                x, y,
                width: 30, height: 20,
                color: `rgb(200, 200, 180)`, // Whitish-brown
                speed: 0.5,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                state: 'wandering', // wandering, fleeing
                fleeTimer: 0,
                mass: 100, // For beam interaction
                canBeAssimilated: true,
                biomatterYield: 10
            };
        }
        function createTree(x,y){
            return {
                type: 'tree',
                x, y,
                trunkWidth: 10, trunkHeight: 20,
                canopyRadius: 25,
                trunkColor: `rgb(139,69,19)`, // Brown
                canopyColor: `rgb(34,139,34)`, // Dark Green
                mass: 150,
                canBeAssimilated: false,
            };
        }
        function createFarmhouse(x,y){
             return {
                type: 'farmhouse',
                x, y,
                width: 80, height: 60,
                color: `rgb(200,180,160)`, // Light brown/beige
                roofColor: `rgb(150,50,50)`, // Reddish
                mass: 1000, // Heavy
                canBeAssimilated: false,
            };
        }


        // --- UFO Controls & Beam ---
        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 0) return;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            currentTouchX = touch.clientX;
            currentTouchY = touch.clientY;
            
            // Check if touch is on a UI button; if so, don't trigger movement
            let targetElement = e.target;
            if (targetElement === beamButton || targetElement === assimilateButton) {
                 isTouching = false; // Don't start UFO movement if a button is pressed
                 return;
            }

            isTouching = true;
            ufo.isMoving = true;
            
            // Set initial target to current UFO world position to avoid jump
            // Then update based on drag
            const worldPos = screenToWorld(currentTouchX, currentTouchY);
            ufo.targetX = ufo.x; 
            ufo.targetY = ufo.y;

            // Dismiss directive message on first interaction
            if (!directiveMessageUI.classList.contains('hidden')) {
                directiveMessageUI.style.opacity = 0;
                setTimeout(() => directiveMessageUI.classList.add('hidden'), 500);
            }
             if (!soundsReady && Tone.context.state !== 'running') { // Ensure sounds start
                initSounds();
            }
            debugLog(`Touch Start: ${touchStartX.toFixed(0)}, ${touchStartY.toFixed(0)}`);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!isTouching || e.touches.length === 0) return;
            const touch = e.touches[0];
            
            const deltaX = touch.clientX - currentTouchX;
            const deltaY = touch.clientY - currentTouchY;

            // Update UFO target world position directly by the drag delta
            ufo.targetX += deltaX;
            ufo.targetY += deltaY;
            
            currentTouchX = touch.clientX;
            currentTouchY = touch.clientY;
            // debugLog(`Touch Move: Target ${ufo.targetX.toFixed(0)}, ${ufo.targetY.toFixed(0)}`);
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (isTouching) {
                isTouching = false;
                // ufo.isMoving = false; // Let it glide to target or stop gradually
                // Keep dx/dy for gliding, or set to 0 for immediate stop
                // ufo.dx = 0; 
                // ufo.dy = 0;
                debugLog("Touch End");
            }
        }
        
        beamButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (ufo.energy > 0) {
                ufo.beamActive = true;
                if (soundsReady && beamSynth.state !== "started") beamSynth.triggerAttack();
                debugLog("Beam ON");
            }
        });
        beamButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            ufo.beamActive = false;
            if (soundsReady && beamSynth.state === "started") beamSynth.triggerRelease();
            if (ufo.heldObject) { // Throw object
                const throwSpeed = 5; // Base throw speed
                // Simple throw in current UFO direction, or based on swipe
                // For now, just release it with a little push downwards
                ufo.heldObject.vx = ufo.dx * 0.5;
                ufo.heldObject.vy = ufo.dy * 0.5 + throwSpeed; 
                ufo.heldObject.isFalling = true;
                debugLog(`Threw ${ufo.heldObject.type}`);
                ufo.heldObject = null;
                assimilateButton.classList.add('hidden');
            }
            debugLog("Beam OFF");
        });

        assimilateButton.addEventListener('click', (e) => { // Using click for simplicity, can be touchstart
            e.preventDefault();
            if (ufo.heldObject && ufo.heldObject.canBeAssimilated && ufo.energy > 10) {
                if (soundsReady) assimilateSynth.triggerAttackRelease("C4", "1s");
                debugLog(`Assimilating ${ufo.heldObject.type}`);
                
                ufo.energy -= 10; // Cost to assimilate
                if(ufo.heldObject.biomatterYield) ufo.biomatter += ufo.heldObject.biomatterYield;
                if(ufo.heldObject.psycheTraceYield) ufo.psycheTrace += ufo.heldObject.psycheTraceYield;

                // Remove object from gameObjects
                const index = gameObjects.indexOf(ufo.heldObject);
                if (index > -1) gameObjects.splice(index, 1);
                
                ufo.heldObject = null;
                assimilateButton.classList.add('hidden');
                ufo.beamActive = false; // Turn off beam after assimilation
                 if (soundsReady && beamSynth.state === "started") beamSynth.triggerRelease();

            } else if (ufo.heldObject && !ufo.heldObject.canBeAssimilated) {
                debugLog(`${ufo.heldObject.type} cannot be assimilated.`);
                // Maybe a "rejected" sound/visual
                if (soundsReady) synth.triggerAttackRelease("A2", "0.2s");
            }
        });


        // --- Game Logic Update ---
        function update(deltaTime) {
            // UFO Movement
            if (ufo.isMoving || ufo.targetX !== ufo.x || ufo.targetY !== ufo.y) {
                const angle = Math.atan2(ufo.targetY - ufo.y, ufo.targetX - ufo.x);
                const targetDx = Math.cos(angle) * ufo.speed;
                const targetDy = Math.sin(angle) * ufo.speed;

                // Ease into target speed
                ufo.dx += (targetDx - ufo.dx) * 0.1;
                ufo.dy += (targetDy - ufo.dy) * 0.1;
                
                // If close to target, stop or reduce speed to prevent overshoot
                const distToTargetSq = (ufo.targetX - ufo.x)**2 + (ufo.targetY - ufo.y)**2;
                if (distToTargetSq < (ufo.speed * 5)**2) { // Within 5 frames of movement
                     if(!isTouching) { // If not actively dragging, start to slow down
                        ufo.dx *= 0.9;
                        ufo.dy *= 0.9;
                        if (Math.abs(ufo.dx) < 0.1 && Math.abs(ufo.dy) < 0.1) {
                            ufo.dx = 0;
                            ufo.dy = 0;
                            ufo.isMoving = false;
                        }
                     }
                }

            } else { // No active target, gradually slow down
                ufo.dx *= 0.95; 
                ufo.dy *= 0.95;
                if (Math.abs(ufo.dx) < 0.1) ufo.dx = 0;
                if (Math.abs(ufo.dy) < 0.1) ufo.dy = 0;
            }
            
            ufo.x += ufo.dx;
            ufo.y += ufo.dy;


            // Camera follows UFO
            camera.x = ufo.x - ufo.screenX;
            camera.y = ufo.y - ufo.screenY;

            // Update active chunks
            updateActiveChunks();

            // Beam Logic
            if (ufo.beamActive && ufo.energy > 0) {
                ufo.energy -= 0.1; // Beam energy cost
                if (ufo.energy < 0) ufo.energy = 0;

                if (!ufo.heldObject) {
                    // Find closest targetable object under beam
                    let closestObject = null;
                    let minDistanceSq = Infinity;
                    const beamWorldX = ufo.x; // Beam originates from UFO center
                    const beamWorldY = ufo.y + ufo.height / 2; // Beam extends downwards

                    gameObjects.forEach(obj => {
                        if (obj.isFalling) return; // Don't pick up falling objects
                        const distSq = (obj.x - beamWorldX)**2 + (obj.y - (beamWorldY + ufo.beamLength / 2))**2; // Target middle of beam
                        const beamRadius = ufo.beamWidth * 2 + obj.width; // Generous radius
                        if (distSq < beamRadius**2 && distSq < minDistanceSq && obj.mass < 500) { // Mass limit
                            closestObject = obj;
                            minDistanceSq = distSq;
                        }
                    });

                    if (closestObject) {
                        ufo.heldObject = closestObject;
                        if (soundsReady) synth.triggerAttackRelease("G4", "0.1s"); // Pickup sound
                        debugLog(`Picked up ${ufo.heldObject.type}`);
                        if (ufo.heldObject.canBeAssimilated) {
                            assimilateButton.classList.remove('hidden');
                        }
                    }
                }
            } else {
                if (ufo.beamActive && ufo.energy <= 0) { // Beam flickers out
                    ufo.beamActive = false;
                    if (soundsReady && beamSynth.state === "started") beamSynth.triggerRelease();
                    if (soundsReady) synth.triggerAttackRelease("C3", "0.5s"); // Power down sound
                }
            }
            
            // Held Object Logic
            if (ufo.heldObject) {
                ufo.heldObject.x = ufo.x; // Object follows UFO x
                ufo.heldObject.y = ufo.y + ufo.height/2 + ufo.beamLength * 0.6; // Held under beam
                ufo.heldObject.vx = 0;
                ufo.heldObject.vy = 0;
                ufo.heldObject.isFalling = false;

                // Drain more energy for heavy objects (conceptual)
                // ufo.energy -= ufo.heldObject.mass * 0.0001;
            }


            // Update Game Objects (NPCs, etc.)
            gameObjects.forEach(obj => {
                if (obj.type === 'cow') {
                    const ufoDistSq = (obj.x - ufo.x)**2 + (obj.y - ufo.y)**2;
                    if (ufoDistSq < (150)**2 || obj.fleeTimer > 0) { // If UFO is close or already fleeing
                        obj.state = 'fleeing';
                        if (obj.fleeTimer <=0) obj.fleeTimer = 180; // Flee for 3 seconds (60fps)
                        
                        const angleToUFO = Math.atan2(ufo.y - obj.y, ufo.x - obj.x);
                        obj.vx = -Math.cos(angleToUFO) * obj.speed * 2; // Flee faster
                        obj.vy = -Math.sin(angleToUFO) * obj.speed * 2;
                    } else {
                        obj.state = 'wandering';
                        if (Math.random() < 0.01) { // Change direction occasionally
                            obj.vx = (Math.random() - 0.5) * obj.speed;
                            obj.vy = (Math.random() - 0.5) * obj.speed;
                        }
                    }
                    obj.x += obj.vx;
                    obj.y += obj.vy;
                    if (obj.fleeTimer > 0) obj.fleeTimer--;

                } else if (obj.isFalling) {
                    obj.vy += 0.5; // Gravity
                    obj.y += obj.vy;
                    obj.x += obj.vx;
                    // Basic ground collision
                    if (obj.y > screenToWorld(0, gameHeight - TILE_SIZE).y) { // Approximate ground
                        obj.y = screenToWorld(0, gameHeight - TILE_SIZE).y;
                        obj.isFalling = false;
                        obj.vx = 0;
                        obj.vy = 0;
                        if (soundsReady) impactSynth.triggerAttackRelease("C2", "0.3s", Tone.now(), 0.8);
                        debugLog(`${obj.type} hit ground.`);
                    }
                }
                // Boundary checks for objects (simple wrap or remove)
                // For now, let updateActiveChunks handle pruning
            });

            // Regenerate energy slowly
            if (ufo.energy < 100) {
                ufo.energy += 0.05;
                if (ufo.energy > 100) ufo.energy = 100;
            }

            // Update UI
            integrityValueUI.textContent = Math.floor(ufo.integrity);
            energyValueUI.textContent = Math.floor(ufo.energy);
            biomatterValueUI.textContent = ufo.biomatter.toString().padStart(4, '0');
            psycheTraceValueUI.textContent = ufo.psycheTrace.toString().padStart(3, '0');
        }

        // --- Rendering ---
        function draw() {
            ctx.clearRect(0, 0, gameWidth, gameHeight);

            // Draw procedural background (chunks)
            activeChunks.forEach(chunk => {
                const screenPos = worldToScreen(chunk.x * CHUNK_SIZE * TILE_SIZE, chunk.y * CHUNK_SIZE * TILE_SIZE);
                const chunkSizePixels = CHUNK_SIZE * TILE_SIZE;
                if (screenPos.x + chunkSizePixels < 0 || screenPos.x > gameWidth ||
                    screenPos.y + chunkSizePixels < 0 || screenPos.y > gameHeight) {
                    return; // Chunk is off-screen
                }
                ctx.fillStyle = chunk.baseColor || '#2a3f2a'; // Default dark green
                ctx.fillRect(screenPos.x, screenPos.y, chunkSizePixels, chunkSizePixels);
                // Could draw tile grid for debugging
                // for (let i = 0; i < CHUNK_SIZE; i++) {
                //     for (let j = 0; j < CHUNK_SIZE; j++) {
                //         ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                //         ctx.strokeRect(screenPos.x + i * TILE_SIZE, screenPos.y + j * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                //     }
                // }
            });


            // Draw Game Objects
            gameObjects.forEach(obj => {
                const sPos = worldToScreen(obj.x, obj.y);
                if (sPos.x + (obj.width || obj.canopyRadius || 0) < 0 || sPos.x - (obj.width || obj.canopyRadius || 0) > gameWidth ||
                    sPos.y + (obj.height || obj.canopyRadius || 0) < 0 || sPos.y - (obj.height || obj.canopyRadius || 0) > gameHeight) {
                    return; // Off-screen
                }

                ctx.save();
                ctx.translate(sPos.x, sPos.y);
                // Could add rotation if objects have an angle property
                
                if (obj.type === 'cow') {
                    // Simple cow: ellipse body, smaller ellipse head
                    ctx.fillStyle = obj.color;
                    // Body
                    ctx.beginPath();
                    ctx.ellipse(0, 0, obj.width / 2, obj.height / 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Head (simple)
                    ctx.beginPath();
                    ctx.ellipse(obj.width / 2 * (obj.vx > 0 ? 0.6 : -0.6), -obj.height/4, obj.width / 4, obj.height / 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obj.type === 'tree') {
                    // Trunk
                    ctx.fillStyle = obj.trunkColor;
                    ctx.fillRect(-obj.trunkWidth / 2, 0, obj.trunkWidth, obj.trunkHeight);
                    // Canopy
                    ctx.fillStyle = obj.canopyColor;
                    ctx.beginPath();
                    ctx.arc(0, -obj.canopyRadius / 2, obj.canopyRadius, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obj.type === 'farmhouse') {
                    // Base
                    ctx.fillStyle = obj.color;
                    ctx.fillRect(-obj.width/2, -obj.height/2, obj.width, obj.height);
                    // Roof
                    ctx.fillStyle = obj.roofColor;
                    ctx.beginPath();
                    ctx.moveTo(-obj.width/2 - 5, -obj.height/2);
                    ctx.lineTo(obj.width/2 + 5, -obj.height/2);
                    ctx.lineTo(0, -obj.height/2 - obj.height*0.4);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.restore();
            });

            // Draw UFO
            const ufoScreenPos = worldToScreen(ufo.x, ufo.y);
            ctx.save();
            ctx.translate(ufoScreenPos.x, ufoScreenPos.y);
            
            // UFO Shadow (simple ellipse)
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(0, ufo.height / 2 + 5, ufo.width / 2, ufo.width / 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // UFO Body
            ctx.fillStyle = '#7f8c8d'; // Grey metallic
            ctx.beginPath();
            ctx.ellipse(0, 0, ufo.width / 2, ufo.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#95a5a6'; // Lighter grey highlight
            ctx.lineWidth = 2;
            ctx.stroke();

            // UFO Dome
            ctx.fillStyle = '#3498db'; // Blueish dome
            ctx.beginPath();
            ctx.ellipse(0, -ufo.height / 4, ufo.width / 3, ufo.domeHeight / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#5dade2';
            ctx.stroke();
            
            ctx.restore();


            // Draw Tractor Beam
            if (ufo.beamActive && ufo.energy > 0) {
                const beamStartX = ufoScreenPos.x;
                const beamStartY = ufoScreenPos.y + ufo.height / 2;
                let beamEndY = beamStartY + ufo.beamLength;
                if (ufo.heldObject) { // Beam shortens to held object
                    const heldObjScreenPos = worldToScreen(ufo.heldObject.x, ufo.heldObject.y);
                    beamEndY = heldObjScreenPos.y - (ufo.heldObject.height || ufo.heldObject.canopyRadius || 10) / 2;
                }

                ctx.beginPath();
                ctx.moveTo(beamStartX - ufo.beamWidth / 2, beamStartY);
                ctx.lineTo(beamStartX - ufo.beamWidth, beamEndY);
                ctx.lineTo(beamStartX + ufo.beamWidth, beamEndY);
                ctx.lineTo(beamStartX + ufo.beamWidth / 2, beamStartY);
                ctx.closePath();

                const gradient = ctx.createLinearGradient(beamStartX, beamStartY, beamStartX, beamEndY);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.1)');
                gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.5)');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0.1)');
                ctx.fillStyle = gradient;
                ctx.fill();

                // Pulsing core effect
                ctx.beginPath();
                ctx.arc(beamStartX, beamStartY + (beamEndY - beamStartY) * Math.random(), ufo.beamWidth * (0.5 + Math.random()*0.5), 0, Math.PI*2);
                ctx.fillStyle = 'rgba(200, 255, 255, 0.8)';
                ctx.fill();
            }
        }

        // --- Game Loop ---
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000; // Delta time in seconds
            lastTime = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // --- Initialization ---
        window.addEventListener('resize', resizeCanvas);
        
        // Touch controls for UFO movement
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false }); // Also handle cancel

        // Initial setup
        resizeCanvas(); // Set initial size
        ufo.x = 0; // Start UFO at world origin
        ufo.y = 0;
        ufo.targetX = ufo.x;
        ufo.targetY = ufo.y;
        camera.x = ufo.x - ufo.screenX; // Center camera
        camera.y = ufo.y - ufo.screenY;
        
        updateActiveChunks(); // Generate initial chunks

        // Add some initial objects if chunks don't populate enough immediately
        if(gameObjects.length < 5) {
            for(let i=0; i<5; i++) gameObjects.push(createCow(Math.random()*500-250, Math.random()*500-250));
        }
        
        // Hide directive message after a few seconds
        setTimeout(() => {
            if (!directiveMessageUI.classList.contains('hidden')) { // Check if not already dismissed
                directiveMessageUI.style.opacity = 0;
                setTimeout(() => directiveMessageUI.classList.add('hidden'), 500);
            }
        }, 5000);

        debugLog("Game initialized. Waiting for user interaction for sound.");
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
